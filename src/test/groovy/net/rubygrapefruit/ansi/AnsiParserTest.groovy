package net.rubygrapefruit.ansi

import net.rubygrapefruit.ansi.token.*
import spock.lang.Specification
import spock.lang.Unroll

/*
 * This Spock specification was generated by the Gradle 'init' task.
 */

class AnsiParserTest extends Specification {
    def nonAscii = "-√æず∫ʙぴ₦ガき∆ç√∫"
    def parser = new AnsiParser()
    def visitor = new TestVisitor()

    def "parses an empty stream"() {
        when:
        parser.newParser("utf-8", visitor).write(bytes(""))

        then:
        visitor.tokens.empty
    }

    def "parses a single line"() {
        when:
        parser.newParser("utf-8", visitor).write(bytes(nonAscii))

        then:
        visitor.tokens.size() == 1
        visitor.tokens[0] instanceof Text
        visitor.tokens[0].text == nonAscii
    }

    def "parses multiple lines separated by new-line"() {
        when:
        parser.newParser("utf-8", visitor).write(bytes("one\ntwo\n\nthree"))

        then:
        visitor.tokens.size() == 6
        visitor.tokens[0] instanceof Text
        visitor.tokens[0].text == "one"
        visitor.tokens[1] instanceof NewLine
        visitor.tokens[2] instanceof Text
        visitor.tokens[2].text == "two"
        visitor.tokens[3] instanceof NewLine
        visitor.tokens[4] instanceof NewLine
        visitor.tokens[5] instanceof Text
        visitor.tokens[5].text == "three"
    }

    def "parses multiple lines separated by new-line and cr"() {
        when:
        parser.newParser("utf-8", visitor).write(bytes("one\r\ntwo\r\n\r\nthree"))

        then:
        visitor.tokens.size() == 9
        visitor.tokens[0] instanceof Text
        visitor.tokens[0].text == "one"
        visitor.tokens[1] instanceof CarriageReturn
        visitor.tokens[2] instanceof NewLine
        visitor.tokens[3] instanceof Text
        visitor.tokens[3].text == "two"
        visitor.tokens[4] instanceof CarriageReturn
        visitor.tokens[5] instanceof NewLine
        visitor.tokens[6] instanceof CarriageReturn
        visitor.tokens[7] instanceof NewLine
        visitor.tokens[8] instanceof Text
        visitor.tokens[8].text == "three"
    }

    def "parses text with a mix of new-line and cr"() {
        when:
        parser.newParser("utf-8", visitor).write(bytes("\rone\ntwo\r\n\n\r"))

        then:
        visitor.tokens.size() == 8
        visitor.tokens[0] instanceof CarriageReturn
        visitor.tokens[1] instanceof Text
        visitor.tokens[1].text == "one"
        visitor.tokens[2] instanceof NewLine
        visitor.tokens[3] instanceof Text
        visitor.tokens[3].text == "two"
        visitor.tokens[4] instanceof CarriageReturn
        visitor.tokens[5] instanceof NewLine
        visitor.tokens[6] instanceof NewLine
        visitor.tokens[7] instanceof CarriageReturn
    }

    def "parses cursor movement control sequence"() {
        when:
        def output = parser.newParser("utf-8", visitor)
        output.write(bytes("\u001B[A"))
        output.write(bytes("\u001B[12A"))
        output.write(bytes("\u001B[004A"))
        output.write(bytes("\u001B[B"))
        output.write(bytes("\u001B[12B"))
        output.write(bytes("\u001B[C"))
        output.write(bytes("\u001B[33C"))
        output.write(bytes("\u001B[D"))
        output.write(bytes("\u001B[20D"))

        then:
        visitor.tokens.size() == 9
        visitor.tokens[0] instanceof CursorUp
        visitor.tokens[0].count == 1
        visitor.tokens[1] instanceof CursorUp
        visitor.tokens[1].count == 12
        visitor.tokens[2] instanceof CursorUp
        visitor.tokens[2].count == 4
        visitor.tokens[3] instanceof CursorDown
        visitor.tokens[3].count == 1
        visitor.tokens[4] instanceof CursorDown
        visitor.tokens[4].count == 12
        visitor.tokens[5] instanceof CursorForward
        visitor.tokens[5].count == 1
        visitor.tokens[6] instanceof CursorForward
        visitor.tokens[6].count == 33
        visitor.tokens[7] instanceof CursorBackward
        visitor.tokens[7].count == 1
        visitor.tokens[8] instanceof CursorBackward
        visitor.tokens[8].count == 20
    }

    def "parses line clear control sequence"() {
        when:
        def output = parser.newParser("utf-8", visitor)
        output.write(bytes("\u001B[K"))
        output.write(bytes("\u001B[0K"))
        output.write(bytes("\u001B[1K"))
        output.write(bytes("\u001B[2K"))
        output.write(bytes("\u001B[3K"))
        output.write(bytes("\u001B[12K"))

        then:
        visitor.tokens.size() == 6
        visitor.tokens[0] instanceof EraseInLine
        visitor.tokens[1] instanceof EraseInLine
        visitor.tokens[2] instanceof EraseToBeginningOfLine
        visitor.tokens[3] instanceof EraseToEndOfLine
        visitor.tokens[4] instanceof UnrecognizedControlSequence
        visitor.tokens[4].sequence == "[3K"
        visitor.tokens[4] instanceof UnrecognizedControlSequence
        visitor.tokens[5].sequence == "[12K"
    }

    @Unroll
    def "parses control sequence - #sequence"() {
        when:
        parser.newParser("utf-8", visitor).write(bytes("\u001B" + sequence + "abc\u001B" + sequence + "\n"))

        then:
        visitor.tokens.size() == 4
        visitor.tokens[0] instanceof UnrecognizedControlSequence
        visitor.tokens[0].sequence == sequence
        visitor.tokens[1] instanceof Text
        visitor.tokens[1].text == "abc"
        visitor.tokens[2] instanceof UnrecognizedControlSequence
        visitor.tokens[2].sequence == sequence
        visitor.tokens[3] instanceof NewLine

        where:
        sequence    | _
        '[q'        | _
        '[1Q'       | _
        '[01234q'   | _
        '[12Q'      | _
        '[1;2m'     | _
        '[123;245m' | _
        '[;2m'      | _
        '[;234m'    | _
        '[2;m'      | _
        '[234;m'    | _
        '[;m'       | _
    }

    @Unroll
    def "parses partial sequence - #sequence"() {
        when:
        parser.newParser("utf-8", visitor).write(bytes("\u001B" + sequence))

        then:
        visitor.tokens.size() == 2
        visitor.tokens[0] instanceof UnrecognizedControlSequence
        visitor.tokens[0].sequence == expected
        visitor.tokens[1] instanceof Text
        visitor.tokens[1].text == delim

        where:
        sequence | expected | delim
        'a'      | ''       | 'a'
        '1;2abc' | ''       | '1;2abc'
        '[ '     | '['      | ' '
        '[_'     | '['      | '_'
        '[['     | '['      | '['
        '[a1'    | '[a'     | '1'
        '[a;'    | '[a'     | ';'
        '[1;m2'  | '[1;m'   | '2'
    }

    byte[] cursorUp() {
        return "\u001B[A".bytes
    }

    byte[] bytes(String str) {
        return str.getBytes("utf-8")
    }

    static class TestVisitor implements Visitor {
        def tokens = []

        @Override
        void visit(Token token) {
            tokens << token
        }
    }
}
