package net.rubygrapefruit.ansi

import net.rubygrapefruit.ansi.token.*
import spock.lang.Specification
import spock.lang.Unroll

/*
 * This Spock specification was generated by the Gradle 'init' task.
 */

class AnsiParserTest extends Specification {
    def nonAscii = "-√æず∫ʙぴ₦ガき∆ç√∫"
    def parser = new AnsiParser()
    def visitor = new TestVisitor()

    def "parses an empty stream"() {
        when:
        parser.newParser("utf-8", visitor).write(bytes(""))

        then:
        visitor.tokens.empty
    }

    def "parses a single line"() {
        when:
        parser.newParser("utf-8", visitor).write(bytes(nonAscii))

        then:
        visitor.tokens.size() == 1
        visitor.tokens[0] instanceof Text
        visitor.tokens[0].text == nonAscii
    }

    def "parses multiple lines separated by new-line"() {
        when:
        parser.newParser("utf-8", visitor).write(bytes("one\ntwo\n\nthree"))

        then:
        visitor.tokens.size() == 6
        visitor.tokens[0] instanceof Text
        visitor.tokens[0].text == "one"
        visitor.tokens[1] instanceof NewLine
        visitor.tokens[2] instanceof Text
        visitor.tokens[2].text == "two"
        visitor.tokens[3] instanceof NewLine
        visitor.tokens[4] instanceof NewLine
        visitor.tokens[5] instanceof Text
        visitor.tokens[5].text == "three"
    }

    def "parses multiple lines separated by new-line and cr"() {
        when:
        parser.newParser("utf-8", visitor).write(bytes("one\r\ntwo\r\n\r\nthree"))

        then:
        visitor.tokens.size() == 9
        visitor.tokens[0] instanceof Text
        visitor.tokens[0].text == "one"
        visitor.tokens[1] instanceof CarriageReturn
        visitor.tokens[2] instanceof NewLine
        visitor.tokens[3] instanceof Text
        visitor.tokens[3].text == "two"
        visitor.tokens[4] instanceof CarriageReturn
        visitor.tokens[5] instanceof NewLine
        visitor.tokens[6] instanceof CarriageReturn
        visitor.tokens[7] instanceof NewLine
        visitor.tokens[8] instanceof Text
        visitor.tokens[8].text == "three"
    }

    def "parses text with a mix of new-line and cr"() {
        when:
        parser.newParser("utf-8", visitor).write(bytes("\rone\ntwo\r\n\n\r"))

        then:
        visitor.tokens.size() == 8
        visitor.tokens[0] instanceof CarriageReturn
        visitor.tokens[1] instanceof Text
        visitor.tokens[1].text == "one"
        visitor.tokens[2] instanceof NewLine
        visitor.tokens[3] instanceof Text
        visitor.tokens[3].text == "two"
        visitor.tokens[4] instanceof CarriageReturn
        visitor.tokens[5] instanceof NewLine
        visitor.tokens[6] instanceof NewLine
        visitor.tokens[7] instanceof CarriageReturn
    }

    @Unroll
    def "parses control sequence - #sequence"() {
        when:
        parser.newParser("utf-8", visitor).write(bytes("\u001B" + sequence + "abc\u001B" + sequence + "\n"))

        then:
        visitor.tokens.size() == 4
        visitor.tokens[0] instanceof ControlSequence
        visitor.tokens[0].sequence == sequence
        visitor.tokens[1] instanceof Text
        visitor.tokens[1].text == "abc"
        visitor.tokens[2] instanceof ControlSequence
        visitor.tokens[2].sequence == sequence
        visitor.tokens[3] instanceof NewLine

        where:
        sequence  | _
        '[A'      | _
        '[1A'     | _
        '[01234A' | _
        '[12A'    | _
        '[1;2m'   | _
        '[;2m'    | _
        '[2;m'    | _
        '[;m'     | _
    }

    @Unroll
    def "parses partial sequence - #sequence"() {
        when:
        parser.newParser("utf-8", visitor).write(bytes("\u001B" + sequence))

        then:
        visitor.tokens.size() == 2
        visitor.tokens[0] instanceof ControlSequence
        visitor.tokens[0].sequence == expected
        visitor.tokens[1] instanceof Text
        visitor.tokens[1].text == delim

        where:
        sequence | expected | delim
        'a'      | ''       | 'a'
        '1;2abc' | ''       | '1;2abc'
        '[ '     | '['      | ' '
        '[_'     | '['      | '_'
        '[['     | '['      | '['
        '[a1'    | '[a'     | '1'
        '[a;'    | '[a'     | ';'
        '[1;m2'  | '[1;m'   | '2'
    }

    byte[] cursorUp() {
        return "\u001B[A".bytes
    }

    byte[] bytes(String str) {
        return str.getBytes("utf-8")
    }

    static class TestVisitor implements Visitor {
        def tokens = []

        @Override
        void visit(Token token) {
            tokens << token
        }
    }
}
