package net.rubygrapefruit.ansi

import net.rubygrapefruit.ansi.token.CarriageReturn
import net.rubygrapefruit.ansi.token.ControlSequence
import net.rubygrapefruit.ansi.token.NewLine
import net.rubygrapefruit.ansi.token.Text
import net.rubygrapefruit.ansi.token.Token

/*
 * This Spock specification was generated by the Gradle 'init' task.
 */
import spock.lang.Specification
import spock.lang.Unroll

class AnsiParserTest extends Specification {
    def nonAscii = "-√æず∫ʙぴ₦ガき∆ç√∫"
    def parser = new AnsiParser()
    def visitor = new TestVisitor()

    def "parses an empty stream"() {
        when:
        parser.parse(bytes(""), "utf-8", visitor)

        then:
        visitor.tokens.empty
    }

    def "parses a single line"() {
        when:
        parser.parse(bytes(nonAscii), "utf-8", visitor)

        then:
        visitor.tokens.size() == 1
        visitor.tokens[0] instanceof Text
        visitor.tokens[0].text == nonAscii
    }

    def "parses multiple lines separated by new-line"() {
        when:
        parser.parse(bytes("one\ntwo\n\nthree"), "utf-8", visitor)

        then:
        visitor.tokens.size() == 6
        visitor.tokens[0] instanceof Text
        visitor.tokens[0].text == "one"
        visitor.tokens[1] instanceof NewLine
        visitor.tokens[2] instanceof Text
        visitor.tokens[2].text == "two"
        visitor.tokens[3] instanceof NewLine
        visitor.tokens[4] instanceof NewLine
        visitor.tokens[5] instanceof Text
        visitor.tokens[5].text == "three"
    }

    def "parses multiple lines separated by new-line and cr"() {
        when:
        parser.parse(bytes("one\r\ntwo\r\n\r\nthree"), "utf-8", visitor)

        then:
        visitor.tokens.size() == 9
        visitor.tokens[0] instanceof Text
        visitor.tokens[0].text == "one"
        visitor.tokens[1] instanceof CarriageReturn
        visitor.tokens[2] instanceof NewLine
        visitor.tokens[3] instanceof Text
        visitor.tokens[3].text == "two"
        visitor.tokens[4] instanceof CarriageReturn
        visitor.tokens[5] instanceof NewLine
        visitor.tokens[6] instanceof CarriageReturn
        visitor.tokens[7] instanceof NewLine
        visitor.tokens[8] instanceof Text
        visitor.tokens[8].text == "three"
    }

    def "parses text with a mix of new-line and cr"() {
        when:
        parser.parse(bytes("\rone\ntwo\r\n\n\r"), "utf-8", visitor)

        then:
        visitor.tokens.size() == 8
        visitor.tokens[0] instanceof CarriageReturn
        visitor.tokens[1] instanceof Text
        visitor.tokens[1].text == "one"
        visitor.tokens[2] instanceof NewLine
        visitor.tokens[3] instanceof Text
        visitor.tokens[3].text == "two"
        visitor.tokens[4] instanceof CarriageReturn
        visitor.tokens[5] instanceof NewLine
        visitor.tokens[6] instanceof NewLine
        visitor.tokens[7] instanceof CarriageReturn
    }

    @Unroll
    def "parses control sequence - #sequence"() {
        when:
        parser.parse(bytes("\u001B[" + sequence + "abc\u001B[" + sequence + "\n"), "utf-8", visitor)

        then:
        visitor.tokens.size() == 4
        visitor.tokens[0] instanceof ControlSequence
        visitor.tokens[0].sequence == sequence
        visitor.tokens[1] instanceof Text
        visitor.tokens[1].text == "abc"
        visitor.tokens[2] instanceof ControlSequence
        visitor.tokens[2].sequence == sequence
        visitor.tokens[3] instanceof NewLine

        where:
        sequence | _
        'A'      | _
        '1A'     | _
        '01234A' | _
        '12A'    | _
        '1;2m'   | _
        ';2m'    | _
        '2;m'    | _
        ';m'     | _
    }

    @Unroll
    def "parses partial sequence - #sequence"() {
        when:
        parser.parse(bytes("\u001B" + sequence), "utf-8", visitor)

        then:
        visitor.tokens.size() == 2
        visitor.tokens[0] instanceof ControlSequence
        visitor.tokens[0].sequence == expected
        visitor.tokens[1] instanceof Text
        visitor.tokens[1].text == delim

        where:
        sequence | expected | delim
        '[ '     | ''       | ' '
        '[_'     | ''       | '_'
        '[['     | ''       | '['
        '[a1'    | 'a'      | '1'
        '[a;'    | 'a'      | ';'
        '[1;m2'  | '1;m'    | '2'
    }

    byte[] cursorUp() {
        return "\u001B[A".bytes
    }

    byte[] bytes(String str) {
        return str.getBytes("utf-8")
    }

    static class TestVisitor implements Visitor {
        def tokens = []

        @Override
        void visit(Token token) {
            tokens << token
        }
    }
}
